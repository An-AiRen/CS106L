### CS106L -- C++

#### Stream

getline和array operation的区别：两者都可以是读到'\n'后停止，但是前者把backslash留在buffer中，后者会把它舍掉。

When should I use StringStream? 

1. Processing strings
2. Formatting input/output
3. Parsing different types.

#### STL -- Standard Template Library >> Algorithms Iterators Adaptors Containers Functors/Lamda

**Container**

sequence container: vector, deque, list

container adapter: queue, stack

associative containers: map, set, unordered_map, unordered_set

**Iterators**

a note: We are going on a journey.

**Template**

+ Function templates

Function templates are special functions that can operate with generic types. That means, the function can be adapted to more than one type or class without repeating the entire code!

```c++
template <typename myType>
myType GetMax(myType a, myType b) {
    return (a>b?a:b);
}
```

Here we create a template function with myType as its template parameter.This template parameter represents a type that has not yet been specified.

+ Class templates

By doing this, class can have members that use template parameters as types:

```c++
template <typename T>
class myPair {
    T values[2];
    public:
	myPair(T first, T second) {
        values[0] = first;
        values[1] = second;
    }
}
```

When initializing  myPair, we should code like this:``myPair<int>(1, 2)``

+ Template specialization

To treat some types with more respects:

```c++
// template specialization
#include <iostream>
using namespace std;

// class template:
template <class T>
class mycontainer {
    T element;
  public:
    mycontainer (T arg) {element=arg;}
    T increase () {return ++element;}
};

// class template specialization:
template <>
class mycontainer <char> {
    char element;
  public:
    mycontainer (char arg) {element=arg;}
    char uppercase ()
    {
      if ((element>='a')&&(element<='z'))
      element+='A'-'a';
      return element;
    }
};

int main () {
  mycontainer<int> myint (7);
  mycontainer<char> mychar ('j');
  cout << myint.increase() << endl;
  cout << mychar.uppercase() << endl;
  return 0;
}
```

Syntax for specialization:``template <> class myContainer<char>{...}``

notice that we precede the class template name with an empty `template<>` parameter list. This is to explicitly declare it as a template specialization.

#### Class

**Special Member Function**

Initializer List is used in initializing the data members of a class. Here's an example:

```c++
public:
    Point(int i = 0, int j = 0):x(i), y(j) {}
```

But there are situations where initialization of data members inside constructor doesn't work and initializer list must be used:

1. For initialization of non-static const data members.const data members must be initialized using Initializer List!
2. For initialization of reference members. 

Three special member functions:

+ default constructor ``StringVector();``

+ copy constructor ``StringVector(const StringVector& other) noexcept;``

+ copy assignment ``StringVector& operator=(const StirngVector& rhs) noexcept;``

+ move constructor ``StringVector(StringVector&& other) noexcept;``

+ move assignment ``StringVector& operator=(StringVector&& rhs) noexcept;``

  StringVector&& rhs turns rhs to R-Value!

  && is  new in C++11. ``int&& a``means "a" is an *R-Value reference*. && is normally only used to declare a parameter of a funtion.

#### Rall(Resource Acquisition Is Initialization)

If we do things like this:

```c++
RawResourceHandle *handle = createNewResource();
handle->performInvalidOperation(); // Throws an exception
...
deleteResource(handle); // Causes a leak.
```

Because the exception throwing in the runtime,  the code ``deleteResource``may never get called,  so the resource leaks. If we implement it using smart pointer which can be released when the variable is out of scope, then the problem can be settled down properly:

```C++
class SmartPointer {
public:
	SmartPointer(RawResourceHandle* _rawHandle) : rawHandle(_rawHandle) {}
    ~SmartPointer() {
        delete rawHandle;
    }
    RawResourceHandle *getPtr(void) const{
        return rawHandle;
    }
private:
    RawResourceHandle *rawHandle;
}

SmartPointer handle(createNewResource());
handle->performInvalidOperation();
```

